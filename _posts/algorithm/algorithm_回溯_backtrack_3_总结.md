```
algorithm_回溯_backtrack_3_总结
```

- 回溯总是和递归联系在一起的
- 要仔细 分析 **回溯 树** 每一层是从**哪个元素**开始的



#### 3.1 回溯总是和递归联系在一起的

```
result = []
def backtrack(res, 路径, 选择列表):
    if 满⾜结束条件:
        res.add(路径)
        return

    for 选择 in 选择列表:
        判断是否需要剪枝, 也就是将不符合题意的循环删除
        
        #在递归之前做出选择，在递归之后撤销刚才的选择
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

​	回溯其实就是不断的调用自身, 直至满足结束条件



#### 3.2 要仔细 分析 **回溯 树** 每一层是从**哪个元素**开始的

方法还是上次说过的  画图 

#### 3.2.1 全排列-------每个元素不重复

> 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
>
> 示例 
>
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

分析:

```
							[]
		[1]  		   [2]   		 [3],,,,,,,,,,,,,,,,,,,,,,,,,,
    [2]	   [3]	 [4]
[3]	  [4]

```

​	第一层是全部( 1 2 3 4  ), 第二层是缺一个, 第三层是缺两个

​	总结起来就是**每个元素不重复**

```c++
//for循环分析
for(int i =0; i<nums.size(); ++i){
    //flag 代表了 是否被使用过
    if(flag[i] == 1) continue;
    track.push_back(nums[i]);
    flag[i] =1;
    //下一层 代表 也是 从头开始
    backtrack(res, nums, track, flag);
    flag[i] =0;
    track.pop_back();
}
```



#### 3.2.2 组合

> 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。
> 你可以按 **任何顺序** 返回答案。
> 输入：n = 4, k = 2
> 输出：
> [
>   [2,4],[3,4],[2,3],[1,2],[1,3],[1,4],
> ]
>
> //解题思路:
> 一般我们在进行答案的搜索的时候, 都是从小的开始,   先1, 然后2, 并且只找比他大的数
> [1,2],[1,3],[1,4],[2,3],[2,4], [3,4]

```
	    			[]
   [1]    			 [2]       ....
[2] [3] [4]
[3] 空  空
```

​	从小的开始,   先1, 然后2, 并且只找比他大的数, 有了3 就不在加入 2

```c++
//for循环 第一句话, 标志着树的 每层 从哪里开始
for(int i =start ; i<=n; ++i){
    track.push_back(i);
    // 下一层树 从哪里开始, 如果顺序有制约, 那么一定和i有关
    backtrack(res, n, k, i+1, track);
    track.pop_back();
}
```



#### 3.2.3 组合总和

> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 *所有* **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
>
> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 
>
> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。
>
> ```
> 输入：candidates = [2,3,6,7], target = 7
> 输出：[[2,2,3],[7]]
> 解释：
> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
> 7 也是一个候选， 7 = 7 。
> 仅有这两种组合。
> ```

```c++
for(int i = start ;i<can.size(); i++){
    track.push_back(can[i]);
    //下一层 还是从本层的 这个元素开始, 因为这个元素可以使用多次
    backtrack(res, can, target, track, sum+can[i], i);
    track.pop_back();
}
```





#### 3.2.4 组合总和3

> 找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：
>
> - 只使用数字1到9
> - 每个数字 **最多使用一次** 
>
> 返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。
>
> **示例 1:**
>
> ```
> 输入: k = 3, n = 7
> 输出: [[1,2,4]]
> 解释:
> 1 + 2 + 4 = 7
> 没有其他符合的组合了。
> ```

```c++
for(int i = start; i<10; ++i){
    track.push_back(i);
	//下一层元素从 下一个元素 后面开始, 因为 元素 不能重复, 
    backtrack(res, k, n, track, i+1, sum +i);
    track.pop_back();
}
```





#### 3.2.5 电话号码的字母组合

> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> ![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

```c++
//一个元素 映射为 一个数组 的元素
vector<char> amap = _map(ch);
for(int i = 0; i<amap.size(); ++i){
    ch2 = amap[i];
    track.push_back(ch2);
    //下一层和 这一层没关系
    backtrack(res, digits, track);
    track.pop_back();
}
```

