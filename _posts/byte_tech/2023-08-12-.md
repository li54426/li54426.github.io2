---
layout: blog
banana: true
category: byte_tech
title:  "Go_"
date:   2023-08-12 21:34:04
background: green
tags:
- byte_tech
- go
---

* content
{:toc}




版本控制是什么?
一种记录一个或若干文件内容变化,以便将来查阅特定版本修订情况的系统

为什么需要版本控制?
更好的关注变更,了解到每个版本的改动是什么,方便对改动的代码进行检查,预防事故发生也能够随时切换到不同的版本,回滚误删误改的问题代码;











| 主题       | 描述                                           |
| ---------- | ---------------------------------------------- |
| 计算机基础 | 数据结构、算法/ 计算机组成原理、计算机网络、操作系统、编译原理        |
| Linux      | linux基础操作、unix环境编程、网络编程          |
| 数据库     | 基础理论ACID、MySQL、NoSQL                     |
| 编程语言   | Java、Go、C/C++、Rust                          |
| 设计模式   | 23种设计模式                                   |
| 中间件                 | API网关、Web/RPC框架、消息队列、缓存、定时调度、数据库中间件ORM、日志系统、配置中型 |
| 分布式                 | 一致性/CAP、事务、等、微服务、拓展性                         |
| 高并发、高性能、高可用 | C10k、进程、线程、线程、异步、池化、缓存、                   |
|                        | CDN、集群、负载均衡、限流、容灾、多活                        |



- 查看目录
- 打开文件
- 两个命令 awk,  sed







SOA(Service-Oriented Architecture)
1.将应用的不同功能单元抽象为服务
2.定义服务之间的通信标准微服务架构:SOA的去中心化演进方向







### service/ message.go

- tcp 客户端, 

```go
package service

import (
	"encoding/json"
	"fmt"
	"github.com/RaymondCode/simple-demo/controller"
	"io"
	"net"
	"sync"
)

// 并发安全的 映射类型
// event.UserId_event.ToUserId
var chatConnMap = sync.Map{}

func RunMessageServer() {
	listen, err := net.Listen("tcp", "127.0.0.1:9090")
	if err != nil {
		fmt.Printf("Run message sever failed: %v\n", err)
		return
	}

	for {
		conn, err := listen.Accept()
		if err != nil {
			fmt.Printf("Accept conn failed: %v\n", err)
			continue
		}

		go process(conn)
	}

}

func process(conn net.Conn) {
	defer conn.Close()

	var buf [256]byte
	for {
		n, err := conn.Read(buf[:])
		if n == 0 {
			if err == io.EOF {
				break
			}
			fmt.Printf("Read message failed: %v\n", err)
			continue
		}
		
        // 在 common.go #L39
        // 请求事件是什么
		var event = controller.MessageSendEvent{}
		_ = json.Unmarshal(buf[:n], &event)
		fmt.Printf("Receive Message：%+v\n", event)

		fromChatKey := fmt.Sprintf("%d_%d", event.UserId, event.ToUserId)
		if len(event.MsgContent) == 0 {
			chatConnMap.Store(fromChatKey, conn)
			continue
		}

		toChatKey := fmt.Sprintf("%d_%d", event.ToUserId, event.UserId)
		writeConn, exist := chatConnMap.Load(toChatKey)
		if !exist {
			fmt.Printf("User %d offline\n", event.ToUserId)
			continue
		}

		pushEvent := controller.MessagePushEvent{
			FromUserId: event.UserId,
			MsgContent: event.MsgContent,
		}
        // 转化为 json 字符串
		pushData, _ := json.Marshal(pushEvent)
		_, err = writeConn.(net.Conn).Write(pushData)
		if err != nil {
			fmt.Printf("Push message failed: %v\n", err)
		}
	}
}

```





#### API / 路由/ 基于 HTTP 协议

做的事情有

- 通过调用 `r.Static("/static", "./public")` 将 "/static" 路径映射到 "./public" 目录，用于提供静态资源文件。
- 接下来，通过调用 `r.LoadHTMLGlob("templates/*")` 加载了所有位于 "templates" 目录下的 HTML 模板文件。
- 之后，定义了一个处理根路径 ("/") 的 GET 请求的**路由**。





- 当GET 的路径为`douyin/feed/`时, 调用`controller.Feed`, 其他也一样
- 注意: Gin 默认情况下会返回 404 错误

```go
func initRouter(r *gin.Engine) {
  // public directory is used to serve static resources
  r.Static("/static", "./public")
  r.LoadHTMLGlob("templates/*")

  // home page
  r.GET("/", func(c *gin.Context) {
    c.HTML(http.StatusOK, "index.html", gin.H{
			"title": "Main website",
		})
  })
  
  apiRouter := r.Group("/douyin")

  // basic apis
  apiRouter.GET("/feed/", controller.Feed)
  apiRouter.GET("/user/", controller.UserInfo)
  apiRouter.POST("/user/register/", controller.Register)
  apiRouter.POST("/user/login/", controller.Login)
    // -------我的工作在这里----------
  apiRouter.POST("/publish/action/", controller.Publish)
  apiRouter.GET("/publish/list/", controller.PublishList)


}
```









#### sync.Map

`sync.Map` 是 Go 语言提供的一种并发安全的映射（Map）结构。它可以在多个 goroutine 并发访问时保证数据的安全性，而不需要额外的加锁操作。

`sync.Map` 的主要特点如下：

1. 无需显式初始化，可以直接声明并使用。
2. 支持并发的读取和写入操作，可以在多个 goroutine 中同时访问。
3. 内部自动进行了并发安全的处理，不需要额外的锁机制。
4. 提供了几个常用的方法来对映射进行操作，如 Store、Load、Delete 等。

需要注意的是，`sync.Map` 相对于普通的 `map` 有一些限制：

1. 不允许使用 `nil` 作为键值。
2. 对于存储的值类型没有约束，可以是任意类型。
3. 没有提供获取映射长度的方法。
