---
layout: blog
banana: true
category: byte_tech
title:  "Go_4_HTTP"
date:   2023-07-31 11:02:06
background: green
tags:
- byte_tech
- go
---

[TOC]






`ctrl` + `/`打开专注模式



![image-20230731154712540](assets/image-20230731154712540.png)







### HTTp 框架




#### 超文本传输协议

- 请求行/状态行
    - 方法名
    - URL
    - 协议版本
- **请求头**/响应头
- 请求体/响应体

```
POST /sis HTTP/1.1
Who: Alex 
Content-Type: text/plain 
Host: 127.0.0.1:8888
Content-Length: 28
Let's watch a movie together
```





#### 问题与展望

- HTTP1 队头阻塞, 传输效率低, 明文传输不安全  (头部太大)
- HTTP2 多路复用, 头部压缩, 二进制协议
- QUIC 基于UDP实现, 解决队头阻塞加, 密减少握手次数, 支持快速启动







#### 盖尔定律

一个切实可行的复杂系统势必是从一个切实可行的**简单系统**发展而来的。从头开始设计的复杂系统根本不切实可行，无法修修补补让它切实可行。你必须由一个切实可行的简单系统重新开始。


先 `run`起来, 再考虑复用, 使用**迭代**的方式进行



#### 合理的 API

不要试图在文档中说明,很多用户不看文档, 这也是在说: **代码的自注释性**

- 可理解性:如ctx.Body(),ctx.GetBody(),不要用ctx. BodyA()
- 简单性:如`ctx.Request. Header.Peek(key)`
    /ctx. GetHeader(key)
- 冗余性
- 兼容性
- 可测性
- 可见性





#### 什么是框架和中间件

在计算机编程和软件开发中，框架中间件（Framework Middleware）是指位于**应用程序和底层框架**之间的软件组件或功能模块。它提供了一种可插拔的方式，用于增强、定制或修改框架的行为，以满足特定的需求。

框架中间件在应用程序和底层框架之间充当了一个抽象层，用于处理和转换请求、响应以及其他相关的操作。它可以介入整个请求 - 响应周期，对数据进行预处理、后处理或者执行其他的附加操作。

框架中间件的主要作用有：

1. 路由和请求处理：中间件可以通过路由机制将请求分发给不同的处理程序，并执行相应的操作。它可以处理 URL 解析、参数提取、权限验证等任务。
2. 数据转换和格式化：中间件可以对请求和响应的数据进行转换、验证和格式化。例如，可以将请求数据解析为特定的格式（如 JSON、XML），或者将响应数据转换为适合客户端的格式。
3. 认证和授权：中间件可以处理用户身份认证和访问控制的任务。例如，它可以检查用户凭据、验证权限，决定是否允许用户继续执行操作。
4. 缓存和性能优化：中间件可以在请求到达框架之前或之后，进行数据缓存、结果缓存以及其他的性能优化操作。它可以减少对底层资源的访问，提高应用程序的响应速度和性能。
5. 日志记录和错误处理：中间件可以记录应用程序的运行日志，并处理异常情况和错误。它可以捕获和处理异常，记录错误信息，使得问题排查和故障修复更加方便有效。

框架中间件的设计目标是提供灵活性和可扩展性，以满足不同应用程序的需求。通过使用框架中间件，开发人员可以以模块化的方式定制和增强框架的功能，使得应用程序的开发和维护更加容易和高效。







#### 洋葱模型



适用场景:

- 日志记录
- 性能统计
- 安全控制
- 事务处理
- 异常处理





#### 什么是 Handler

在计算机编程和软件开发中，Handler（处理器）是指用于处理特定事件或请求的代码块、函数或对象。它充当了一个中间人，接收来自外部系统或其它组件的事件或请求，并对其进行适当的处理和响应。

Handler 的主要任务是根据接收到的事件或请求的类型，执行相应的逻辑。它可以包括各种操作，如数据处理、错误处理、用户界面更新、网络通信、数据库查询等。

Handler 可以存在于不同的上下文中。例如，对于图形用户界面（GUI），一个按钮点击事件的处理者就是一个 Handler；在服务端开发中，一个 HTTP 请求的处理者也可以被称为 Handler。它们根据特定的事件或请求类型，执行相应的操作以满足需求。

在许多框架和库中，一般会有一套明确定义的规则和接口来定义和使用 Handler。这些规则和接口可以使开发人员更方便地定义和注册 Handler，并将其与相应的事件或请求关联起来。

总之，Handler 是用于处理特定事件或请求的代码块、函数或对象，它负责执行相关的逻辑以满足需求。通过合理的使用和组织 Handler，可以有效地管理和处理系统中的各种事件和请求。















框架路由实际上就是为URL匹配对应的处理函数(Handlers)

- 静态路由:/a/b/c./a/b/d
- 参数路 :/a/:id/c(/a/b/c,/a/d/c)./*all
- 路由修复: 
    - 如果只注册了 /a/b，但是访问的 URI 是 /a/b/，那可以提供自动重定向到 /a/b 能力；同样，如果只注册了 /a/b/，但是访问的 URI 是 /a/b，那可以提供自动重定向到 /a/b/ 能力

- 冲突路由以及优先级
    - 同时注册 /a/b 和 /:id/b，并设定优先级。比如：当请求 URI 为 /a/b 时，优先匹配静态路由 /a/b

- 匹配HTTP方法
- 多处理函数:方便添加中间件







如何匹配HTTP方法











#### 开发流程

- 1.明确需求:考虑清楚要解决什么问题,有哪些需求
- 2.业界调研:业界都有哪些解决方案可供参考
- 3.方案权衡:思考不同方案的取舍
- 4.方案评审:相关同学对不同方案做评审
- 5.确定开发:确定最合适的方案进行开发





```go
type Server interface{
	Serve(c context. Context, conn network.Conn) error
}


type Conn interface {
    Read(b []byte)(n int, err error)
    Write(b []byte)(n int, err error)
}
```





[字节内部网络模型](https://github.com/cloudwego/netpoll)



#### 总结

- API设计:可理解性、简单性
- 中间件设计: 洋葱模型
- 路由设计:前缀匹配树
- 协议层设计:抽象出合适的接口
- 网络层设计: 网络模型





#### 设计点

- 存下全部Header
- 减少系统调用次数
- 能够复用内存
- 能够多次读





```go
type Reader interface {
    // 开始读的位置
    Peek(n int)([]byte, error)
    Discard(n int)(discarded int, err error)
    Release() error 
    Size() int 
    Read(b []byte)(l int, err error)
}
```





#### 网络库比较

- `go net `  流式友好, 小包性能高
- `netpoll` 中大包性能高, 时延低





#### 针对协议的优化

- 找到Header Line边界:`\r\n`, 先找到`\n`再看它前一个是不是`\r`
- 热点资源**池化**



针对协议相关的Headers

- 1.通过 Header key 首字母快速筛除掉完全**不可能**的 key
- 2.解析对应 value到独立字段
- 3.使用 byte slice 管理对应 header 存储,方便复用请求体中同样处理的Key:
    User-Agent、 Content-Type、 Content-Length、 Connection、 Transfer-Encoding



[开源 json 库](https:/github.com/bytedance/sonic)



#### SIMD技术



SIMD（Single Instruction, Multiple Data）是一种**并行计算**的技术，它在同一时间执行相同的指令来处理多个数据元素。它是在计算机体系结构中用于向量化操作的一种方式。

传统的计算机指令集架构（ISA）以标量方式执行指令，即每次执行一个指令处理一个数据元素。而 SIMD 架构通过引入特殊的寄存器和指令集，能够同时处理多个数据元素，加速并行计算。

SIMD 技术适用于那些可以**被划分为多个独立任务**的数据，并且这些任务可以并行地进行相同的计算。它可以提高多媒体处理、图形渲染、信号处理、科学计算等应用的性能。

SIMD 指令集提供了一系列的指令，用于在单个时钟周期内同时对多个数据进行相同的操作。这些指令可以一次性处理多个数据元素，例如同时对四个浮点数执行加法操作。

常见的 SIMD 指令集包括 Intel 的 SSE（Streaming SIMD Extensions）、AMD 的 3DNow!、ARM 的 NEON 等。这些指令集通常有不同的版本，支持不同的宽度（如 128 位、256 位）和数据类型（如整数、浮点数）。

使用 SIMD 技术可以显著提高计算性能，但需要合理的程序设计和优化以充分利用 SIMD 指令集的并行计算能力。许多编程语言和编译器提供了对 SIMD 的支持，使得开发者能够方便地利用 SIMD 技术来加速计算。





#### 性能不是全部

- 追求性
- 追求易用, 减少误用
- 打通内部生态
- 文档建设、用户群建设, 









### RPC框架

#### 什么是 RPC

RPC（Remote Procedure Call）是一种用于实现**分布式**系统通信的协议和机制。它允许一个进程（客户端）调用另一个运行在不同地址空间的进程（服务器）中的函数或方法，就像调用本地函数一样。

RPC 的工作原理如下：

1. 客户端通过本地调用的方式调用远程服务器的函数或方法。
2. 客户端的 RPC stub（存根）将调用信息打包成网络可传输的消息，并发送给远程服务器。
3. 服务器的 RPC stub 接收到消息后，解包调用信息并调用对应的函数或方法。
4. 函数或方法执行完毕后，将结果打包成响应消息，并发送给客户端。
5. 客户端的 RPC stub 接收到响应消息后，解包结果并返回给本地调用方。

通过 RPC，开发人员可以轻松地在分布式系统中调用远程服务，而无需关心底层的网络通信细节。它隐藏了网络通信的复杂性，使得分布式系统开发更加方便和高效。

RPC 的优势包括：

1. 简化分布式系统开发：RPC 提供了一种简单而直观的方法来调用远程服务，使得分布式系统开发更加容易和高效。
2. 高效的网络通信：RPC 可以使用高效的序列化和网络传输协议，以最小的开销在分布式系统间传递数据。
3. 抽象底层细节：RPC 抽象了底层的网络通信细节，使得开发人员可以更专注于业务逻辑的实现，而不用关心底层通信协议和传输细节。

常见的 RPC 框架包括 gRPC、Apache Thrift、Spring Cloud、Dubbo 等。这些框架提供了丰富的功能和工具，使得分布式系统的开发、部署和管理更加便捷和可靠。







RPC需要解决的问题

- 1 函数**映射**
- 2.数据**转换**成字节流
- 3.网络传输



RPC 的概念模型：

- User、
- User-Stub、
- RPC-Runtime、
- Server-Stub、
- Server





#### 优缺点

优点

- 单一职责,有利于分工协作和运维开发
- 可扩展性强, 资源使用率更优
- 故障隔离, 服务的整体可靠性更高



坏处

- 1.服务宕机,对方应该如何处理?
- 2.在调用过程中发生网络异常,如何保证消息的可达性?
- 3.请求量突增导致服务无法及时处理, 有哪些应对措施?









#### 分层设计

- 编解码层 包括生成代码
- 协议层
- 网络层





- 语言特定的格式
    - 许多编程语言都内建了将内存对象编码为字节序列的支持,例如Java有java.io.Serializable
- 文本格式JSON、XML、CSV等文本格式,具有人类可读性
- 二进制编码, 具备跨语言和高性能等优点,常见有Thrift的 BinaryProtocol, Protobuf



TLV编码

- Tag:标签,可以理解为类型
- Lenght:长度
- Value:值,Value也可以是个TLV结构



增加了冗余信息



#### 编码层如何选

- 兼容性, 支持自动增加新的字段,而不影响老的服务,这将提高系统的灵活度
- 通用性支持跨平台、跨语言
- 性能从空间和时间两个维度来考虑,也就是编码后**数据大小**和**编码耗费时长**

